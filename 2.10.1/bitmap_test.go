package freetype2

import (
	"image/color"
	"testing"

	"github.com/flga/freetype2/fixed"
)

func TestLibrary_NewBitmap(t *testing.T) {
	l, err := NewLibrary()
	if err != nil {
		t.Fatalf("unable to create lib: %v", err)
	}
	tests := []struct {
		name    string
		l       *Library
		want    *Bitmap
		wantErr error
	}{
		{name: "nilLib", l: nil, want: nil, wantErr: ErrInvalidLibraryHandle},
		{
			name: "ok",
			l:    l,
			want: &Bitmap{
				userCreated: true,
			},
			wantErr: nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.l.NewBitmap()
			defer got.Free()

			if err != tt.wantErr {
				t.Errorf("Library.NewBitmap() error = %v, wantErr %v", err, tt.wantErr)
			}
			if diff := diff(got, tt.want); diff != nil {
				t.Errorf("Library.NewBitmap() = %v", diff)
			}
		})
	}
}

func TestBitmap_Free(t *testing.T) {
	t.Run("lib.Free", func(t *testing.T) {
		l, err := NewLibrary()
		if err != nil {
			t.Fatalf("unable to create lib: %v", err)
		}

		bitmap, err := l.NewBitmap()
		if err != nil {
			t.Fatalf("unable to create bitmap: %v", err)
		}

		l.Free()

		if bitmap.ptr != nil {
			t.Errorf("bitmap.ptr should be nil")
		}
	})

	t.Run("newBitmap", func(t *testing.T) {
		l, err := NewLibrary()
		if err != nil {
			t.Fatalf("unable to create lib: %v", err)
		}
		defer l.Free()

		bitmap, err := l.NewBitmap()
		if err != nil {
			t.Fatalf("unable to create bitmap: %v", err)
		}
		bitmapCopy, err := l.NewBitmap()
		if err != nil {
			t.Fatalf("unable to create bitmap: %v", err)
		}
		if err := bitmap.CopyTo(l, bitmapCopy); err != nil {
			t.Fatalf("unable to copy bitmap: %v", err)
		}

		if bitmap.ptr == bitmapCopy.ptr {
			t.Fatalf("pointers are equal")
		}

		if err := bitmap.Free(); err != nil {
			t.Fatalf("unable to free bitmap: %v", err)
		}
		if bitmap.ptr != nil {
			t.Fatalf("ptr should be nil")
		}
		if bitmapCopy.ptr == nil {
			t.Fatalf("ptr should not be nil")
		}

		if err := bitmapCopy.Free(); err != nil {
			t.Fatalf("unable to free bitmap: %v", err)
		}
		if bitmapCopy.ptr != nil {
			t.Fatalf("ptr should be nil")
		}
	})

	t.Run("outlineSlot", func(t *testing.T) {
		l, err := NewLibrary()
		if err != nil {
			t.Fatalf("unable to create lib: %v", err)
		}
		defer l.Free()
		face, err := l.NewFaceFromPath(testdata("go", "Go-Regular.ttf"), 0, 0)
		if err != nil {
			t.Fatalf("unable to load face: %v", err)
		}
		defer face.Free()
		if err := face.SetCharSize(14<<6, 14<<6, 72, 72); err != nil {
			t.Fatalf("unable to set char size: %v", err)
		}
		if err := face.LoadChar('A', LoadDefault); err != nil {
			t.Fatalf("unable to load char: %v", err)
		}

		bitmap := face.GlyphSlot().Bitmap
		bitmapCopy, err := l.NewBitmap()
		if err != nil {
			t.Fatalf("unable to create bitmap: %v", err)
		}
		if err := bitmap.CopyTo(l, bitmapCopy); err != nil {
			t.Fatalf("unable to copy bitmap: %v", err)
		}

		if err := bitmap.Free(); err != nil {
			t.Fatalf("unable to free bitmap: %v", err)
		}
		if bitmap.ptr == nil {
			t.Fatalf("ptr should not be nil")
		}
		if bitmapCopy.ptr == nil {
			t.Fatalf("ptr should not be nil")
		}

		if err := bitmapCopy.Free(); err != nil {
			t.Fatalf("unable to free bitmap: %v", err)
		}
		if bitmap.ptr == nil {
			t.Fatalf("ptr should not be nil")
		}
		if bitmapCopy.ptr != nil {
			t.Fatalf("ptr should be nil")
		}
	})

	t.Run("bitmapSlot", func(t *testing.T) {
		l, err := NewLibrary()
		if err != nil {
			t.Fatalf("unable to create lib: %v", err)
		}
		defer l.Free()
		face, err := l.NewFaceFromPath(testdata("go", "Go-Regular.ttf"), 0, 0)
		if err != nil {
			t.Fatalf("unable to load face: %v", err)
		}
		defer face.Free()
		if err := face.SetCharSize(14<<6, 14<<6, 72, 72); err != nil {
			t.Fatalf("unable to set char size: %v", err)
		}
		if err := face.LoadChar('A', LoadRender); err != nil {
			t.Fatalf("unable to load char: %v", err)
		}

		bitmap := face.GlyphSlot().Bitmap
		bitmapCopy, err := l.NewBitmap()
		if err != nil {
			t.Fatalf("unable to create bitmap: %v", err)
		}
		if err := bitmap.CopyTo(l, bitmapCopy); err != nil {
			t.Fatalf("unable to copy bitmap: %v", err)
		}

		if err := bitmap.Free(); err != nil {
			t.Fatalf("unable to free bitmap: %v", err)
		}
		if bitmap.ptr == nil {
			t.Fatalf("ptr should not be nil")
		}
		if bitmapCopy.ptr == nil {
			t.Fatalf("ptr should not be nil")
		}

		if err := bitmapCopy.Free(); err != nil {
			t.Fatalf("unable to free bitmap: %v", err)
		}
		if bitmap.ptr == nil {
			t.Fatalf("ptr should not be nil")
		}
		if bitmapCopy.ptr != nil {
			t.Fatalf("ptr should be nil")
		}
	})

	t.Run("outlineGlyph", func(t *testing.T) {
		l, err := NewLibrary()
		if err != nil {
			t.Fatalf("unable to create lib: %v", err)
		}
		defer l.Free()
		face, err := l.NewFaceFromPath(testdata("go", "Go-Regular.ttf"), 0, 0)
		if err != nil {
			t.Fatalf("unable to load face: %v", err)
		}
		defer face.Free()
		if err := face.SetCharSize(14<<6, 14<<6, 72, 72); err != nil {
			t.Fatalf("unable to set char size: %v", err)
		}
		if err := face.LoadChar('A', LoadDefault); err != nil {
			t.Fatalf("unable to load char: %v", err)
		}

		glyph, err := face.GlyphSlot().Glyph()
		if err != nil {
			t.Fatalf("unable to get glyph: %v", err)
		}
		defer glyph.Free()

		outlineGlyph, ok := glyph.(*OutlineGlyph)
		if !ok {
			t.Fatalf("glyph is not an outline")
		}

		bitmapGlyph, err := outlineGlyph.ToBitmap(RenderModeNormal, Vector26_6{}, true)
		if err != nil {
			t.Fatalf("unable to convert to bitmap: %v", err)
		}
		defer bitmapGlyph.Free()

		bitmap := bitmapGlyph.Bitmap
		bitmapCopy, err := l.NewBitmap()
		if err != nil {
			t.Fatalf("unable to create bitmap: %v", err)
		}
		if err := bitmap.CopyTo(l, bitmapCopy); err != nil {
			t.Fatalf("unable to copy bitmap: %v", err)
		}

		if err := bitmap.Free(); err != nil {
			t.Fatalf("unable to free bitmap: %v", err)
		}
		if bitmap.ptr == nil {
			t.Fatalf("ptr should not be nil")
		}
		if bitmapCopy.ptr == nil {
			t.Fatalf("ptr should not be nil")
		}

		if err := bitmapCopy.Free(); err != nil {
			t.Fatalf("unable to free bitmap: %v", err)
		}
		if bitmap.ptr == nil {
			t.Fatalf("ptr should not be nil")
		}
		if bitmapCopy.ptr != nil {
			t.Fatalf("ptr should be nil")
		}
	})

	t.Run("bitmapGlyph", func(t *testing.T) {
		l, err := NewLibrary()
		if err != nil {
			t.Fatalf("unable to create lib: %v", err)
		}
		defer l.Free()
		face, err := l.NewFaceFromPath(testdata("go", "Go-Regular.ttf"), 0, 0)
		if err != nil {
			t.Fatalf("unable to load face: %v", err)
		}
		defer face.Free()
		if err := face.SetCharSize(14<<6, 14<<6, 72, 72); err != nil {
			t.Fatalf("unable to set char size: %v", err)
		}
		if err := face.LoadChar('A', LoadRender); err != nil {
			t.Fatalf("unable to load char: %v", err)
		}

		glyph, err := face.GlyphSlot().Glyph()
		if err != nil {
			t.Fatalf("unable to get glyph: %v", err)
		}
		defer glyph.Free()

		bitmapGlyph, ok := glyph.(*BitmapGlyph)
		if !ok {
			t.Fatalf("glyph is not an outline")
		}
		defer bitmapGlyph.Free()

		bitmap := bitmapGlyph.Bitmap
		bitmapCopy, err := l.NewBitmap()
		if err != nil {
			t.Fatalf("unable to create bitmap: %v", err)
		}
		if err := bitmap.CopyTo(l, bitmapCopy); err != nil {
			t.Fatalf("unable to copy bitmap: %v", err)
		}

		if err := bitmap.Free(); err != nil {
			t.Fatalf("unable to free bitmap: %v", err)
		}
		if bitmap.ptr == nil {
			t.Fatalf("ptr should not be nil")
		}
		if bitmapCopy.ptr == nil {
			t.Fatalf("ptr should not be nil")
		}

		if err := bitmapCopy.Free(); err != nil {
			t.Fatalf("unable to free bitmap: %v", err)
		}
		if bitmap.ptr == nil {
			t.Fatalf("ptr should not be nil")
		}
		if bitmapCopy.ptr != nil {
			t.Fatalf("ptr should be nil")
		}
	})
}

func TestBitmap_CopyTo(t *testing.T) {
	t.Run("nil", func(t *testing.T) {
		l, err := NewLibrary()
		if err != nil {
			t.Fatalf("unable to create lib: %v", err)
		}
		defer l.Free()

		b, err := l.NewBitmap()
		if err != nil {
			t.Fatalf("unable to crete bitmap: %v", err)
		}
		defer b.Free()

		target, err := l.NewBitmap()
		if err != nil {
			t.Fatalf("unable to crete bitmap: %v", err)
		}
		defer target.Free()

		var nilBitmap *Bitmap
		if err := nilBitmap.CopyTo(nil, nil); err != ErrInvalidArgument {
			t.Errorf("Bitmap.CopyTo() error = %v, want %v", err, ErrInvalidArgument)
		}
		if err := b.CopyTo(nil, nil); err != ErrInvalidLibraryHandle {
			t.Errorf("Bitmap.CopyTo() error = %v, want %v", err, ErrInvalidLibraryHandle)
		}
		if err := b.CopyTo(l, nil); err != ErrInvalidArgument {
			t.Errorf("Bitmap.CopyTo() error = %v, want %v", err, ErrInvalidArgument)
		}
		if err := b.CopyTo(l, target); err != nil {
			t.Errorf("Bitmap.CopyTo() error = %v", err)
		}
	})
	l, err := NewLibrary()
	if err != nil {
		t.Fatalf("unable to create lib: %v", err)
	}
	defer l.Free()

	face, err := l.NewFaceFromPath(testdata("go", "Go-Regular.ttf"), 0, 0)
	if err != nil {
		t.Fatalf("unable to load face: %v", err)
	}
	defer face.Free()

	if err := face.SetCharSize(14<<6, 14<<6, 72, 72); err != nil {
		t.Fatalf("unable to set char size: %v", err)
	}
	if err := face.LoadChar('A', LoadRender); err != nil {
		t.Fatalf("unable to load char: %v", err)
	}

	bitmap := face.GlyphSlot().Bitmap
	bitmapCopy, err := l.NewBitmap()
	if err != nil {
		t.Fatalf("unable to create bitmap: %v", err)
	}
	if err := bitmap.CopyTo(l, bitmapCopy); err != nil {
		t.Fatalf("unable to copy bitmap: %v", err)
	}

	if bitmap.ptr == bitmapCopy.ptr {
		t.Fatalf("ptrs should not be equal")
	}

	want := *bitmap //shallow is fine
	want.userCreated = true
	if diff := diff(bitmapCopy, &want); diff != nil {
		t.Fatalf("Bitmap.CopyTo() %v", diff)
	}

	newBitmap, err := l.NewBitmap()
	if err != nil {
		t.Fatalf("unable to create bitmap: %v", err)
	}

	oldptr := bitmap.ptr
	if err := newBitmap.CopyTo(l, bitmap); err != nil {
		t.Fatalf("unable to copy bitmap: %v", err)
	}

	if bitmap.ptr != oldptr {
		t.Fatalf("ptrs should be equal")
	}
	if diff := diff(bitmap, &Bitmap{}); diff != nil {
		t.Fatalf("Bitmap.CopyTo() %v", diff)
	}
}

func TestBitmap_Embolden(t *testing.T) {
	t.Run("nil", func(t *testing.T) {
		l, err := NewLibrary()
		if err != nil {
			t.Fatalf("unable to create lib: %v", err)
		}
		defer l.Free()

		empty, err := l.NewBitmap()
		if err != nil {
			t.Fatalf("unable to crete bitmap: %v", err)
		}
		defer empty.Free()

		var nilBitmap *Bitmap
		if err := nilBitmap.Embolden(nil, 0, 0); err != ErrInvalidArgument {
			t.Errorf("Bitmap.Embolden() error = %v, want %v", err, ErrInvalidArgument)
		}
		if err := empty.Embolden(nil, 0, 0); err != ErrInvalidLibraryHandle {
			t.Errorf("Bitmap.Embolden() error = %v, want %v", err, ErrInvalidLibraryHandle)
		}
		if err := empty.Embolden(l, 0, 0); err != ErrInvalidArgument {
			t.Errorf("Bitmap.Embolden() error = %v, want %v", err, ErrInvalidArgument)
		}
	})

	l, err := NewLibrary()
	if err != nil {
		t.Fatalf("unable to create lib: %v", err)
	}
	defer l.Free()

	face, err := l.NewFaceFromPath(testdata("go", "Go-Regular.ttf"), 0, 0)
	if err != nil {
		t.Fatalf("unable to load face: %v", err)
	}
	defer face.Free()

	if err := face.SetCharSize(14<<6, 14<<6, 72, 72); err != nil {
		t.Fatalf("unable to set char size: %v", err)
	}
	if err := face.LoadChar('A', LoadRender); err != nil {
		t.Fatalf("unable to load char: %v", err)
	}

	aBitmap := face.GlyphSlot().Bitmap
	empty, err := l.NewBitmap()
	if err != nil {
		t.Fatalf("unable to create bitmap: %v", err)
	}
	defer empty.Free()

	var emboldened []byte

	switch 32 << (^uint(0) >> 63) {
	case 64:
		emboldened = []byte{
			0x00, 0x00, 0x00, 0x35, 0xff, 0xff, 0x8f, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0xbf, 0xff, 0xff, 0xef, 0x02, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x02, 0xef, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x43, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x00, 0x00, 0x00,
			0x00, 0x00, 0xdb, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0x00, 0x00,
			0x00, 0x05, 0xfb, 0xff, 0xef, 0xfb, 0xff, 0xff, 0x47, 0x00, 0x00,
			0x00, 0x4f, 0xff, 0xff, 0x7f, 0x5b, 0xff, 0xff, 0xdf, 0x00, 0x00,
			0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00,
			0x0b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4f, 0x00,
			0x5b, 0xff, 0xff, 0x9f, 0x50, 0x50, 0x8d, 0xff, 0xff, 0xef, 0x00,
			0xfb, 0xff, 0xff, 0x0e, 0x00, 0x00, 0x04, 0xef, 0xff, 0xff, 0x0a,
			0xb3, 0xff, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xff, 0xfe, 0x0a,
		}
	case 32:
		emboldened = []byte{
			0x00, 0x00, 0x00, 0x35, 0xff, 0xff, 0x90, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0xbf, 0xff, 0xff, 0xf7, 0x02, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x02, 0xef, 0xff, 0xff, 0xff, 0x42, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x43, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x00, 0x00, 0x00,
			0x00, 0x00, 0xdb, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0x00, 0x00,
			0x00, 0x06, 0xff, 0xff, 0xef, 0xfb, 0xff, 0xff, 0x4c, 0x00, 0x00,
			0x00, 0x4e, 0xff, 0xff, 0x7f, 0x5b, 0xff, 0xff, 0xe8, 0x00, 0x00,
			0x00, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x07, 0x00,
			0x0b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x57, 0x00,
			0x5b, 0xff, 0xff, 0x9f, 0x50, 0x50, 0x8d, 0xff, 0xff, 0xf8, 0x00,
			0xfb, 0xff, 0xff, 0x0e, 0x00, 0x00, 0x04, 0xef, 0xff, 0xff, 0x0b,
			0xb3, 0xff, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xff, 0xff, 0x0b,
		}
	}

	tests := []struct {
		name       string
		b          *Bitmap
		xStr, yStr fixed.Int26_6
		want       *Bitmap
		wantErr    error
	}{
		{name: "nilBitmap", b: nil, wantErr: ErrInvalidArgument},
		{name: "empty", b: empty, want: empty, wantErr: ErrInvalidArgument},
		{
			name: "goRegular-A",
			b:    aBitmap,
			xStr: 1 << 6,
			yStr: 1 << 6,
			want: &Bitmap{
				userCreated: true, // test makes a copy, irrelevant otherwise
				Rows:        12,
				Width:       11,
				Pitch:       11,
				Buffer:      emboldened,
				NumGrays:    256,
				PixelMode:   2,
			},
			wantErr: nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var copy *Bitmap
			if tt.b != nil {
				var err error
				copy, err = l.NewBitmap()
				if err != nil {
					t.Fatalf("unable to create bitmap: %v", err)
				}
				if err := tt.b.CopyTo(l, copy); err != nil {
					t.Fatalf("unable to copy: %v", err)
				}
			}

			if err := copy.Embolden(l, tt.xStr, tt.yStr); err != tt.wantErr {
				t.Errorf("Bitmap.Embolden() error = %v, wantErr %v", err, tt.wantErr)
			}
			if diff := diff(copy, tt.want); diff != nil {
				t.Errorf("Bitmap.Embolden() %v", diff)
			}
		})
	}
}

func TestBitmap_Convert(t *testing.T) {
	l, err := NewLibrary()
	if err != nil {
		t.Fatalf("unable to create lib: %v", err)
	}
	defer l.Free()

	face, err := l.NewFaceFromPath(testdata("go", "Go-Regular.ttf"), 0, 0)
	if err != nil {
		t.Fatalf("unable to load face: %v", err)
	}
	defer face.Free()

	if err := face.SetCharSize(14<<6, 14<<6, 72, 72); err != nil {
		t.Fatalf("unable to set char size: %v", err)
	}

	bitmap := func(flags LoadFlag) func() (*Bitmap, error) {
		return func() (*Bitmap, error) {
			if err := face.LoadChar('A', flags); err != nil {
				return nil, err
			}

			b, err := l.NewBitmap()
			if err != nil {
				return nil, err
			}

			if err := face.GlyphSlot().Bitmap.CopyTo(l, b); err != nil {
				b.Free()
				return nil, err
			}

			return b, nil
		}
	}

	bgra := func() (*Bitmap, error) {
		base, err := bitmap(LoadRender)()
		if err != nil {
			return nil, err
		}

		b, err := l.NewBitmap()
		if err != nil {
			return nil, err
		}

		if _, err := base.Blend(l, Vector26_6{}, b, color.RGBA{0, 0, 0, 255}); err != nil {
			return nil, err
		}

		return b, nil
	}

	intSize := 32 << (^uint(0) >> 63)

	var gray0 []byte
	if intSize == 64 {
		gray0 = []byte{
			0x00, 0x00, 0x00, 0x35, 0xff, 0x8f, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x8e, 0xff, 0xe5, 0x02, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x02, 0xe5, 0xc4, 0xff, 0x3f, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x41, 0xfe, 0x27, 0xf4, 0x97, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x9b, 0xc5, 0x00, 0xa8, 0xeb, 0x04, 0x00, 0x00,
			0x00, 0x05, 0xee, 0x6f, 0x00, 0x53, 0xff, 0x47, 0x00, 0x00,
			0x00, 0x4e, 0xfd, 0x1a, 0x00, 0x09, 0xf3, 0x9f, 0x00, 0x00,
			0x00, 0xa7, 0xff, 0xfc, 0xfc, 0xfc, 0xff, 0xf0, 0x07, 0x00,
			0x0b, 0xf5, 0x75, 0x28, 0x28, 0x28, 0x61, 0xff, 0x4f, 0x00,
			0x5a, 0xf6, 0x0e, 0x00, 0x00, 0x00, 0x04, 0xe9, 0xa7, 0x00,
			0xb3, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xf4, 0x0a,
		}
	} else if intSize == 32 {
		gray0 = []byte{
			0x00, 0x00, 0x00, 0x35, 0xff, 0x90, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x8e, 0xff, 0xe5, 0x02, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x02, 0xe5, 0xc4, 0xff, 0x40, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x41, 0xfe, 0x27, 0xf4, 0x98, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x9b, 0xc5, 0x00, 0xa8, 0xeb, 0x04, 0x00, 0x00,
			0x00, 0x06, 0xee, 0x6f, 0x00, 0x53, 0xff, 0x48, 0x00, 0x00,
			0x00, 0x4e, 0xfd, 0x1a, 0x00, 0x09, 0xf3, 0xa0, 0x00, 0x00,
			0x00, 0xa7, 0xff, 0xfc, 0xfc, 0xfc, 0xff, 0xf0, 0x07, 0x00,
			0x0b, 0xf5, 0x75, 0x28, 0x28, 0x28, 0x61, 0xff, 0x50, 0x00,
			0x5a, 0xf6, 0x0e, 0x00, 0x00, 0x00, 0x04, 0xe9, 0xa8, 0x00,
			0xb3, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xf5, 0x0b,
		}
	}

	var gray3 []byte
	if intSize == 64 {
		gray3 = []byte{
			0x00, 0x00, 0x00, 0x35, 0xff, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x8e, 0xff, 0xe5, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x02, 0xe5, 0xc4, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x41, 0xfe, 0x27, 0xf4, 0x97, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x9b, 0xc5, 0x00, 0xa8, 0xeb, 0x04, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x05, 0xee, 0x6f, 0x00, 0x53, 0xff, 0x47, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x4e, 0xfd, 0x1a, 0x00, 0x09, 0xf3, 0x9f, 0x00, 0x00, 0x00, 0x00,
			0x00, 0xa7, 0xff, 0xfc, 0xfc, 0xfc, 0xff, 0xf0, 0x07, 0x00, 0x00, 0x00,
			0x0b, 0xf5, 0x75, 0x28, 0x28, 0x28, 0x61, 0xff, 0x4f, 0x00, 0x00, 0x00,
			0x5a, 0xf6, 0x0e, 0x00, 0x00, 0x00, 0x04, 0xe9, 0xa7, 0x00, 0x00, 0x00,
			0xb3, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xf4, 0x0a, 0x00, 0x00,
		}
	} else if intSize == 32 {
		gray3 = []byte{
			0x00, 0x00, 0x00, 0x35, 0xff, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x8e, 0xff, 0xe5, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x02, 0xe5, 0xc4, 0xff, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x41, 0xfe, 0x27, 0xf4, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x9b, 0xc5, 0x00, 0xa8, 0xeb, 0x04, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x06, 0xee, 0x6f, 0x00, 0x53, 0xff, 0x48, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x4e, 0xfd, 0x1a, 0x00, 0x09, 0xf3, 0xa0, 0x00, 0x00, 0x00, 0x00,
			0x00, 0xa7, 0xff, 0xfc, 0xfc, 0xfc, 0xff, 0xf0, 0x07, 0x00, 0x00, 0x00,
			0x0b, 0xf5, 0x75, 0x28, 0x28, 0x28, 0x61, 0xff, 0x50, 0x00, 0x00, 0x00,
			0x5a, 0xf6, 0x0e, 0x00, 0x00, 0x00, 0x04, 0xe9, 0xa8, 0x00, 0x00, 0x00,
			0xb3, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xf5, 0x0b, 0x00, 0x00,
		}
	}

	var lcd0 []byte
	if intSize == 64 {
		lcd0 = []byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x35, 0x89, 0xe0, 0xff, 0xff, 0xe2, 0x8f, 0x3b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3a, 0x8e, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xe5, 0x93, 0x3b, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3c, 0x94, 0xe5, 0xff, 0xcf, 0xc4, 0xc5, 0xf5, 0xff, 0xe8, 0x93, 0x3f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x41, 0x95, 0xe9, 0xfe, 0xc8, 0x70, 0x27, 0x52, 0xaa, 0xf4, 0xff, 0xe8, 0x97, 0x43, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x47, 0x9b, 0xea, 0xfe, 0xc5, 0x71, 0x1b, 0x00, 0x08, 0x54, 0xa8, 0xf3, 0xff, 0xeb, 0x9b, 0x43, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x48, 0xa0, 0xee, 0xfe, 0xc3, 0x6f, 0x1c, 0x00, 0x00, 0x00, 0x0a, 0x53, 0xa7, 0xf4, 0xff, 0xed, 0x9b, 0x47, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x4e, 0xa2, 0xf1, 0xfd, 0xc4, 0x6c, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x51, 0xa9, 0xf3, 0xff, 0xed, 0x9f, 0x4b, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x53, 0xa7, 0xf2, 0xff, 0xff, 0xfe, 0xfd, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfd, 0xff, 0xff, 0xff, 0xf0, 0xa3, 0x4b, 0x07, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x0b, 0x55, 0xad, 0xf5, 0xfa, 0xbc, 0x75, 0x34, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x2b, 0x61, 0xa8, 0xef, 0xff, 0xf2, 0xa3, 0x4f, 0x08, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x0e, 0x5a, 0xae, 0xf7, 0xf6, 0xb1, 0x59, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x42, 0x9a, 0xe9, 0xff, 0xf2, 0xa7, 0x53, 0x08, 0x00, 0x00,
			0x00, 0x00, 0x0f, 0x5f, 0xb3, 0xf8, 0xf1, 0xa7, 0x53, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3b, 0x8f, 0xe1, 0xff, 0xf4, 0xab, 0x53, 0x0a, 0x00,
		}
	} else if intSize == 32 {
		lcd0 = []byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x35, 0x89, 0xdf, 0xff, 0xff, 0xe2, 0x90, 0x3c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3a, 0x8e, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xe5, 0x94, 0x3c, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3c, 0x94, 0xe5, 0xff, 0xcf, 0xc4, 0xc5, 0xf5, 0xff, 0xe8, 0x94, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x41, 0x95, 0xe9, 0xfe, 0xc8, 0x70, 0x27, 0x52, 0xaa, 0xf4, 0xff, 0xe8, 0x98, 0x44, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x47, 0x9b, 0xea, 0xfe, 0xc5, 0x71, 0x1b, 0x00, 0x08, 0x54, 0xa8, 0xf3, 0xff, 0xeb, 0x9c, 0x44, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x48, 0xa0, 0xee, 0xfe, 0xc3, 0x6f, 0x1c, 0x00, 0x00, 0x00, 0x0a, 0x53, 0xa7, 0xf4, 0xff, 0xee, 0x9c, 0x48, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x4e, 0xa2, 0xf1, 0xfd, 0xc4, 0x6c, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x51, 0xa9, 0xf3, 0xff, 0xee, 0xa0, 0x4c, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x53, 0xa7, 0xf2, 0xff, 0xff, 0xfe, 0xfd, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfd, 0xff, 0xff, 0xff, 0xf0, 0xa4, 0x4c, 0x07, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x0b, 0x55, 0xad, 0xf5, 0xfa, 0xbc, 0x75, 0x34, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x2b, 0x61, 0xa8, 0xef, 0xff, 0xf2, 0xa4, 0x50, 0x09, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x0e, 0x5a, 0xae, 0xf7, 0xf6, 0xb1, 0x59, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x42, 0x9a, 0xe9, 0xff, 0xf2, 0xa8, 0x54, 0x09, 0x00, 0x00,
			0x00, 0x00, 0x0f, 0x5f, 0xb3, 0xf8, 0xf1, 0xa7, 0x53, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3b, 0x8f, 0xe1, 0xff, 0xf5, 0xac, 0x54, 0x0b, 0x00,
		}
	}

	var lcd2 []byte
	if intSize == 64 {
		lcd2 = []byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x35, 0x89, 0xe0, 0xff, 0xff, 0xe2, 0x8f, 0x3b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3a, 0x8e, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xe5, 0x93, 0x3b, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3c, 0x94, 0xe5, 0xff, 0xcf, 0xc4, 0xc5, 0xf5, 0xff, 0xe8, 0x93, 0x3f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x41, 0x95, 0xe9, 0xfe, 0xc8, 0x70, 0x27, 0x52, 0xaa, 0xf4, 0xff, 0xe8, 0x97, 0x43, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x47, 0x9b, 0xea, 0xfe, 0xc5, 0x71, 0x1b, 0x00, 0x08, 0x54, 0xa8, 0xf3, 0xff, 0xeb, 0x9b, 0x43, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x48, 0xa0, 0xee, 0xfe, 0xc3, 0x6f, 0x1c, 0x00, 0x00, 0x00, 0x0a, 0x53, 0xa7, 0xf4, 0xff, 0xed, 0x9b, 0x47, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x4e, 0xa2, 0xf1, 0xfd, 0xc4, 0x6c, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x51, 0xa9, 0xf3, 0xff, 0xed, 0x9f, 0x4b, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x53, 0xa7, 0xf2, 0xff, 0xff, 0xfe, 0xfd, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfd, 0xff, 0xff, 0xff, 0xf0, 0xa3, 0x4b, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x0b, 0x55, 0xad, 0xf5, 0xfa, 0xbc, 0x75, 0x34, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x2b, 0x61, 0xa8, 0xef, 0xff, 0xf2, 0xa3, 0x4f, 0x08, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x0e, 0x5a, 0xae, 0xf7, 0xf6, 0xb1, 0x59, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x42, 0x9a, 0xe9, 0xff, 0xf2, 0xa7, 0x53, 0x08, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x0f, 0x5f, 0xb3, 0xf8, 0xf1, 0xa7, 0x53, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3b, 0x8f, 0xe1, 0xff, 0xf4, 0xab, 0x53, 0x0a, 0x00, 0x00,
		}
	} else if intSize == 32 {
		lcd2 = []byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x35, 0x89, 0xdf, 0xff, 0xff, 0xe2, 0x90, 0x3c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3a, 0x8e, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xe5, 0x94, 0x3c, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3c, 0x94, 0xe5, 0xff, 0xcf, 0xc4, 0xc5, 0xf5, 0xff, 0xe8, 0x94, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x41, 0x95, 0xe9, 0xfe, 0xc8, 0x70, 0x27, 0x52, 0xaa, 0xf4, 0xff, 0xe8, 0x98, 0x44, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x47, 0x9b, 0xea, 0xfe, 0xc5, 0x71, 0x1b, 0x00, 0x08, 0x54, 0xa8, 0xf3, 0xff, 0xeb, 0x9c, 0x44, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x48, 0xa0, 0xee, 0xfe, 0xc3, 0x6f, 0x1c, 0x00, 0x00, 0x00, 0x0a, 0x53, 0xa7, 0xf4, 0xff, 0xee, 0x9c, 0x48, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x4e, 0xa2, 0xf1, 0xfd, 0xc4, 0x6c, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x51, 0xa9, 0xf3, 0xff, 0xee, 0xa0, 0x4c, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x53, 0xa7, 0xf2, 0xff, 0xff, 0xfe, 0xfd, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfd, 0xff, 0xff, 0xff, 0xf0, 0xa4, 0x4c, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x0b, 0x55, 0xad, 0xf5, 0xfa, 0xbc, 0x75, 0x34, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x2b, 0x61, 0xa8, 0xef, 0xff, 0xf2, 0xa4, 0x50, 0x09, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x0e, 0x5a, 0xae, 0xf7, 0xf6, 0xb1, 0x59, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x42, 0x9a, 0xe9, 0xff, 0xf2, 0xa8, 0x54, 0x09, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x0f, 0x5f, 0xb3, 0xf8, 0xf1, 0xa7, 0x53, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3b, 0x8f, 0xe1, 0xff, 0xf5, 0xac, 0x54, 0x0b, 0x00, 0x00,
		}
	}

	var lcd4 []byte
	if intSize == 64 {
		lcd4 = []byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x35, 0x89, 0xe0, 0xff, 0xff, 0xe2, 0x8f, 0x3b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3a, 0x8e, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xe5, 0x93, 0x3b, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3c, 0x94, 0xe5, 0xff, 0xcf, 0xc4, 0xc5, 0xf5, 0xff, 0xe8, 0x93, 0x3f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x41, 0x95, 0xe9, 0xfe, 0xc8, 0x70, 0x27, 0x52, 0xaa, 0xf4, 0xff, 0xe8, 0x97, 0x43, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x47, 0x9b, 0xea, 0xfe, 0xc5, 0x71, 0x1b, 0x00, 0x08, 0x54, 0xa8, 0xf3, 0xff, 0xeb, 0x9b, 0x43, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x48, 0xa0, 0xee, 0xfe, 0xc3, 0x6f, 0x1c, 0x00, 0x00, 0x00, 0x0a, 0x53, 0xa7, 0xf4, 0xff, 0xed, 0x9b, 0x47, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x4e, 0xa2, 0xf1, 0xfd, 0xc4, 0x6c, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x51, 0xa9, 0xf3, 0xff, 0xed, 0x9f, 0x4b, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x53, 0xa7, 0xf2, 0xff, 0xff, 0xfe, 0xfd, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfd, 0xff, 0xff, 0xff, 0xf0, 0xa3, 0x4b, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x0b, 0x55, 0xad, 0xf5, 0xfa, 0xbc, 0x75, 0x34, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x2b, 0x61, 0xa8, 0xef, 0xff, 0xf2, 0xa3, 0x4f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x0e, 0x5a, 0xae, 0xf7, 0xf6, 0xb1, 0x59, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x42, 0x9a, 0xe9, 0xff, 0xf2, 0xa7, 0x53, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x0f, 0x5f, 0xb3, 0xf8, 0xf1, 0xa7, 0x53, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3b, 0x8f, 0xe1, 0xff, 0xf4, 0xab, 0x53, 0x0a, 0x00, 0x00, 0x00, 0x00,
		}
	} else if intSize == 32 {
		lcd4 = []byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x35, 0x89, 0xdf, 0xff, 0xff, 0xe2, 0x90, 0x3c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3a, 0x8e, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xe5, 0x94, 0x3c, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3c, 0x94, 0xe5, 0xff, 0xcf, 0xc4, 0xc5, 0xf5, 0xff, 0xe8, 0x94, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x41, 0x95, 0xe9, 0xfe, 0xc8, 0x70, 0x27, 0x52, 0xaa, 0xf4, 0xff, 0xe8, 0x98, 0x44, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x47, 0x9b, 0xea, 0xfe, 0xc5, 0x71, 0x1b, 0x00, 0x08, 0x54, 0xa8, 0xf3, 0xff, 0xeb, 0x9c, 0x44, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x48, 0xa0, 0xee, 0xfe, 0xc3, 0x6f, 0x1c, 0x00, 0x00, 0x00, 0x0a, 0x53, 0xa7, 0xf4, 0xff, 0xee, 0x9c, 0x48, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x4e, 0xa2, 0xf1, 0xfd, 0xc4, 0x6c, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x51, 0xa9, 0xf3, 0xff, 0xee, 0xa0, 0x4c, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x53, 0xa7, 0xf2, 0xff, 0xff, 0xfe, 0xfd, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfd, 0xff, 0xff, 0xff, 0xf0, 0xa4, 0x4c, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x0b, 0x55, 0xad, 0xf5, 0xfa, 0xbc, 0x75, 0x34, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x2b, 0x61, 0xa8, 0xef, 0xff, 0xf2, 0xa4, 0x50, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x0e, 0x5a, 0xae, 0xf7, 0xf6, 0xb1, 0x59, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x42, 0x9a, 0xe9, 0xff, 0xf2, 0xa8, 0x54, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x0f, 0x5f, 0xb3, 0xf8, 0xf1, 0xa7, 0x53, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3b, 0x8f, 0xe1, 0xff, 0xf5, 0xac, 0x54, 0x0b, 0x00, 0x00, 0x00, 0x00,
		}
	}

	var bgra0 []byte
	if intSize == 64 {
		bgra0 = []byte{
			0x00, 0x00, 0x00, 0x35, 0xff, 0x8f, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x8e, 0xff, 0xe5, 0x02, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x02, 0xe5, 0xc4, 0xff, 0x3f, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x41, 0xfe, 0x27, 0xf4, 0x97, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x9b, 0xc5, 0x00, 0xa8, 0xeb, 0x04, 0x00, 0x00,
			0x00, 0x05, 0xee, 0x6f, 0x00, 0x53, 0xff, 0x47, 0x00, 0x00,
			0x00, 0x4e, 0xfd, 0x1a, 0x00, 0x09, 0xf3, 0x9f, 0x00, 0x00,
			0x00, 0xa7, 0xff, 0xfc, 0xfc, 0xfc, 0xff, 0xf0, 0x07, 0x00,
			0x0b, 0xf5, 0x75, 0x28, 0x28, 0x28, 0x61, 0xff, 0x4f, 0x00,
			0x5a, 0xf6, 0x0e, 0x00, 0x00, 0x00, 0x04, 0xe9, 0xa7, 0x00,
			0xb3, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xf4, 0x0a,
		}
	} else if intSize == 32 {
		bgra0 = []byte{
			0x00, 0x00, 0x00, 0x35, 0xff, 0x90, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x8e, 0xff, 0xe5, 0x02, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x02, 0xe5, 0xc4, 0xff, 0x40, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x41, 0xfe, 0x27, 0xf4, 0x98, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x9b, 0xc5, 0x00, 0xa8, 0xeb, 0x04, 0x00, 0x00,
			0x00, 0x06, 0xee, 0x6f, 0x00, 0x53, 0xff, 0x48, 0x00, 0x00,
			0x00, 0x4e, 0xfd, 0x1a, 0x00, 0x09, 0xf3, 0xa0, 0x00, 0x00,
			0x00, 0xa7, 0xff, 0xfc, 0xfc, 0xfc, 0xff, 0xf0, 0x07, 0x00,
			0x0b, 0xf5, 0x75, 0x28, 0x28, 0x28, 0x61, 0xff, 0x50, 0x00,
			0x5a, 0xf6, 0x0e, 0x00, 0x00, 0x00, 0x04, 0xe9, 0xa8, 0x00,
			0xb3, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xf5, 0x0b,
		}
	}

	var bgra3 []byte
	if intSize == 64 {
		bgra3 = []byte{
			0x00, 0x00, 0x00, 0x35, 0xff, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x8e, 0xff, 0xe5, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x02, 0xe5, 0xc4, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x41, 0xfe, 0x27, 0xf4, 0x97, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x9b, 0xc5, 0x00, 0xa8, 0xeb, 0x04, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x05, 0xee, 0x6f, 0x00, 0x53, 0xff, 0x47, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x4e, 0xfd, 0x1a, 0x00, 0x09, 0xf3, 0x9f, 0x00, 0x00, 0x00, 0x00,
			0x00, 0xa7, 0xff, 0xfc, 0xfc, 0xfc, 0xff, 0xf0, 0x07, 0x00, 0x00, 0x00,
			0x0b, 0xf5, 0x75, 0x28, 0x28, 0x28, 0x61, 0xff, 0x4f, 0x00, 0x00, 0x00,
			0x5a, 0xf6, 0x0e, 0x00, 0x00, 0x00, 0x04, 0xe9, 0xa7, 0x00, 0x00, 0x00,
			0xb3, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xf4, 0x0a, 0x00, 0x00,
		}
	} else if intSize == 32 {
		bgra3 = []byte{
			0x00, 0x00, 0x00, 0x35, 0xff, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x8e, 0xff, 0xe5, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x02, 0xe5, 0xc4, 0xff, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x41, 0xfe, 0x27, 0xf4, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x9b, 0xc5, 0x00, 0xa8, 0xeb, 0x04, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x06, 0xee, 0x6f, 0x00, 0x53, 0xff, 0x48, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x4e, 0xfd, 0x1a, 0x00, 0x09, 0xf3, 0xa0, 0x00, 0x00, 0x00, 0x00,
			0x00, 0xa7, 0xff, 0xfc, 0xfc, 0xfc, 0xff, 0xf0, 0x07, 0x00, 0x00, 0x00,
			0x0b, 0xf5, 0x75, 0x28, 0x28, 0x28, 0x61, 0xff, 0x50, 0x00, 0x00, 0x00,
			0x5a, 0xf6, 0x0e, 0x00, 0x00, 0x00, 0x04, 0xe9, 0xa8, 0x00, 0x00, 0x00,
			0xb3, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xf5, 0x0b, 0x00, 0x00,
		}
	}

	tests := []struct {
		name      string
		src       func() (*Bitmap, error)
		l         *Library
		alignment int
		want      *Bitmap
		wantErr   error
	}{
		{name: "nilSrc", src: nil, l: nil, want: nil, wantErr: ErrInvalidArgument},
		{name: "nilLib", src: bitmap(LoadDefault), l: nil, want: nil, wantErr: ErrInvalidLibraryHandle},

		{
			name:      "mono-0",
			src:       bitmap(LoadRender | LoadTargetMono),
			l:         l,
			alignment: 0,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       9,
				Pitch:       9,
				Buffer: []byte{
					0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00,
					0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00,
					0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
					0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00,
					0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
					0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
					0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
					0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
				},
				NumGrays:  2,
				PixelMode: 2,
			},
			wantErr: nil,
		},
		{
			name:      "mono-1",
			src:       bitmap(LoadRender | LoadTargetMono),
			l:         l,
			alignment: 1,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       9,
				Pitch:       9,
				Buffer: []byte{
					0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00,
					0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00,
					0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
					0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00,
					0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
					0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
					0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
					0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
				},
				NumGrays:  2,
				PixelMode: 2,
			},
			wantErr: nil,
		},
		{
			name:      "mono-2",
			src:       bitmap(LoadRender | LoadTargetMono),
			l:         l,
			alignment: 2,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       9,
				Pitch:       10,
				Buffer: []byte{
					0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00,
					0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
					0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
					0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00,
					0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00,
				},
				NumGrays:  2,
				PixelMode: 2,
			},
			wantErr: nil,
		},
		{
			name:      "gray-0",
			src:       bitmap(LoadRender | LoadTargetNormal),
			l:         l,
			alignment: 0,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       10,
				Pitch:       10,
				Buffer:      gray0,
				NumGrays:    256,
				PixelMode:   2,
			},
			wantErr: nil,
		},
		{
			name:      "gray-1",
			src:       bitmap(LoadRender | LoadTargetNormal),
			l:         l,
			alignment: 1,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       10,
				Pitch:       10,
				Buffer:      gray0,
				NumGrays:    256,
				PixelMode:   2,
			},
			wantErr: nil,
		},
		{
			name:      "gray-3",
			src:       bitmap(LoadRender | LoadTargetNormal),
			l:         l,
			alignment: 3,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       10,
				Pitch:       12,
				Buffer:      gray3,
				NumGrays:    256,
				PixelMode:   2,
			},
			wantErr: nil,
		},
		{
			name:      "lcd-0",
			src:       bitmap(LoadRender | LoadTargetLCD),
			l:         l,
			alignment: 0,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       33,
				Pitch:       33,
				Buffer:      lcd0,
				NumGrays:    256,
				PixelMode:   2,
			},
			wantErr: nil,
		},
		{
			name:      "lcd-1",
			src:       bitmap(LoadRender | LoadTargetLCD),
			l:         l,
			alignment: 1,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       33,
				Pitch:       33,
				Buffer:      lcd0,
				NumGrays:    256,
				PixelMode:   2,
			},
			wantErr: nil,
		},
		{
			name:      "lcd-2",
			src:       bitmap(LoadRender | LoadTargetLCD),
			l:         l,
			alignment: 2,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       33,
				Pitch:       34,
				Buffer:      lcd2,
				NumGrays:    256,
				PixelMode:   2,
			},
			wantErr: nil,
		},
		{
			name:      "lcd-4",
			src:       bitmap(LoadRender | LoadTargetLCD),
			l:         l,
			alignment: 4,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       33,
				Pitch:       36,
				Buffer:      lcd4,
				NumGrays:    256,
				PixelMode:   2,
			},
			wantErr: nil,
		},
		{
			name:      "bgra-0",
			src:       bgra,
			l:         l,
			alignment: 0,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       10,
				Pitch:       10,
				Buffer:      bgra0,
				NumGrays:    256,
				PixelMode:   2,
			},
			wantErr: nil,
		},
		{
			name:      "bgra-1",
			src:       bgra,
			l:         l,
			alignment: 1,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       10,
				Pitch:       10,
				Buffer:      bgra0,
				NumGrays:    256,
				PixelMode:   2,
			},
			wantErr: nil,
		},
		{
			name:      "bgra-2",
			src:       bgra,
			l:         l,
			alignment: 2,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       10,
				Pitch:       10,
				Buffer:      bgra0,
				NumGrays:    256,
				PixelMode:   2,
			},
			wantErr: nil,
		},
		{
			name:      "bgra-3",
			src:       bgra,
			l:         l,
			alignment: 3,
			want: &Bitmap{
				userCreated: true, //this actually matters, Convert() creates a new bitmap
				Rows:        11,
				Width:       10,
				Pitch:       12,
				Buffer:      bgra3,
				NumGrays:    256,
				PixelMode:   2,
			},
			wantErr: nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var src *Bitmap
			var err error
			if tt.src != nil {
				src, err = tt.src()
				if err != nil {
					t.Fatalf("unable to get bitmap: %v", err)
				}
				defer src.Free()
			}

			got, err := src.Convert(tt.l, tt.alignment)
			if err != tt.wantErr {
				t.Errorf("Bitmap.Convert() error = %v, want %v", err, tt.wantErr)
			}

			if diff := diff(got, tt.want); diff != nil {
				t.Errorf("Bitmap.Convert() %v", diff)
			}
		})
	}
}

func TestBitmap_Blend(t *testing.T) {
	t.Run("nil", func(t *testing.T) {
		l, err := NewLibrary()
		if err != nil {
			t.Fatalf("unable to create lib: %v", err)
		}
		defer l.Free()

		b, err := l.NewBitmap()
		if err != nil {
			t.Fatalf("unable to create bitmap: %v", err)
		}
		defer b.Free()

		target, err := l.NewBitmap()
		if err != nil {
			t.Fatalf("unable to create bitmap: %v", err)
		}
		defer target.Free()

		var nilBitmap *Bitmap
		if _, err := nilBitmap.Blend(nil, Vector26_6{}, nil, color.RGBA{}); err != ErrInvalidArgument {
			t.Errorf("Bitmap.Blend() error = %v, want %v", err, ErrInvalidArgument)
		}
		if _, err := b.Blend(nil, Vector26_6{}, nil, color.RGBA{}); err != ErrInvalidLibraryHandle {
			t.Errorf("Bitmap.Blend() error = %v, want %v", err, ErrInvalidLibraryHandle)
		}
		if _, err := b.Blend(l, Vector26_6{}, nil, color.RGBA{}); err != ErrInvalidArgument {
			t.Errorf("Bitmap.Blend() error = %v, want %v", err, ErrInvalidArgument)
		}
		if _, err := b.Blend(l, Vector26_6{}, target, color.RGBA{}); err != nil {
			t.Errorf("Bitmap.Blend() error = %v", err)
		}
	})

	l, err := NewLibrary()
	if err != nil {
		t.Fatalf("unable to create lib: %v", err)
	}
	defer l.Free()

	face, err := l.NewFaceFromPath(testdata("go", "Go-Regular.ttf"), 0, 0)
	if err != nil {
		t.Fatalf("unable to load face: %v", err)
	}
	defer face.Free()

	if err := face.SetCharSize(14<<6, 14<<6, 72, 72); err != nil {
		t.Fatalf("unable to set char size: %v", err)
	}

	if err := face.LoadChar('A', LoadRender); err != nil {
		t.Fatalf("unable to load char: %v", err)
	}

	b, err := l.NewBitmap()
	if err != nil {
		t.Fatalf("unable to create bitmap: %v", err)
	}
	defer b.Free()

	intSize := 32 << (^uint(0) >> 63)

	var srcBuf []byte
	if intSize == 64 {
		srcBuf = []byte{
			0x00, 0x00, 0x00, 0x35, 0xff, 0x8f, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x8e, 0xff, 0xe5, 0x02, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x02, 0xe5, 0xc4, 0xff, 0x3f, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x41, 0xfe, 0x27, 0xf4, 0x97, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x9b, 0xc5, 0x00, 0xa8, 0xeb, 0x04, 0x00, 0x00,
			0x00, 0x05, 0xee, 0x6f, 0x00, 0x53, 0xff, 0x47, 0x00, 0x00,
			0x00, 0x4e, 0xfd, 0x1a, 0x00, 0x09, 0xf3, 0x9f, 0x00, 0x00,
			0x00, 0xa7, 0xff, 0xfc, 0xfc, 0xfc, 0xff, 0xf0, 0x07, 0x00,
			0x0b, 0xf5, 0x75, 0x28, 0x28, 0x28, 0x61, 0xff, 0x4f, 0x00,
			0x5a, 0xf6, 0x0e, 0x00, 0x00, 0x00, 0x04, 0xe9, 0xa7, 0x00,
			0xb3, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xf4, 0x0a,
		}
	} else if intSize == 32 {
		srcBuf = []byte{
			0x00, 0x00, 0x00, 0x35, 0xff, 0x90, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x8e, 0xff, 0xe5, 0x02, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x02, 0xe5, 0xc4, 0xff, 0x40, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x41, 0xfe, 0x27, 0xf4, 0x98, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x9b, 0xc5, 0x00, 0xa8, 0xeb, 0x04, 0x00, 0x00,
			0x00, 0x06, 0xee, 0x6f, 0x00, 0x53, 0xff, 0x48, 0x00, 0x00,
			0x00, 0x4e, 0xfd, 0x1a, 0x00, 0x09, 0xf3, 0xa0, 0x00, 0x00,
			0x00, 0xa7, 0xff, 0xfc, 0xfc, 0xfc, 0xff, 0xf0, 0x07, 0x00,
			0x0b, 0xf5, 0x75, 0x28, 0x28, 0x28, 0x61, 0xff, 0x50, 0x00,
			0x5a, 0xf6, 0x0e, 0x00, 0x00, 0x00, 0x04, 0xe9, 0xa8, 0x00,
			0xb3, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xf5, 0x0b,
		}
	}

	wantSrcBitmap := &Bitmap{
		Rows:      11,
		Width:     10,
		Pitch:     10,
		Buffer:    srcBuf,
		NumGrays:  256,
		PixelMode: PixelModeGray,
	}

	if diff := diff(face.GlyphSlot().Bitmap, wantSrcBitmap); diff != nil {
		t.Fatalf("slot.bitmap = %v", diff)
	}

	var blendBuf []byte
	if intSize == 64 {
		blendBuf = []byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x35, 0x35, 0x35, 0xff, 0xff, 0xff, 0xff, 0x8f, 0x8f, 0x8f, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8e, 0x8e, 0x8e, 0x8e, 0xff, 0xff, 0xff, 0xff, 0xe5, 0xe5, 0xe5, 0xe5, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02, 0xe5, 0xe5, 0xe5, 0xe5, 0xc4, 0xc4, 0xc4, 0xc4, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x3f, 0x3f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x41, 0x41, 0x41, 0xfe, 0xfe, 0xfe, 0xfe, 0x27, 0x27, 0x27, 0x27, 0xf4, 0xf4, 0xf4, 0xf4, 0x97, 0x97, 0x97, 0x97, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9b, 0x9b, 0x9b, 0x9b, 0xc5, 0xc5, 0xc5, 0xc5, 0x00, 0x00, 0x00, 0x00, 0xa8, 0xa8, 0xa8, 0xa8, 0xeb, 0xeb, 0xeb, 0xeb, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0xee, 0xee, 0xee, 0xee, 0x6f, 0x6f, 0x6f, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x53, 0x53, 0x53, 0x53, 0xff, 0xff, 0xff, 0xff, 0x47, 0x47, 0x47, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x4e, 0x4e, 0x4e, 0x4e, 0xfd, 0xfd, 0xfd, 0xfd, 0x1a, 0x1a, 0x1a, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x09, 0xf3, 0xf3, 0xf3, 0xf3, 0x9f, 0x9f, 0x9f, 0x9f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0xa7, 0xa7, 0xa7, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf0, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00,
			0x0b, 0x0b, 0x0b, 0x0b, 0xf5, 0xf5, 0xf5, 0xf5, 0x75, 0x75, 0x75, 0x75, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x61, 0x61, 0x61, 0x61, 0xff, 0xff, 0xff, 0xff, 0x4f, 0x4f, 0x4f, 0x4f, 0x00, 0x00, 0x00, 0x00,
			0x5a, 0x5a, 0x5a, 0x5a, 0xf6, 0xf6, 0xf6, 0xf6, 0x0e, 0x0e, 0x0e, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0xe9, 0xe9, 0xe9, 0xe9, 0xa7, 0xa7, 0xa7, 0xa7, 0x00, 0x00, 0x00, 0x00,
			0xb3, 0xb3, 0xb3, 0xb3, 0xa7, 0xa7, 0xa7, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x8f, 0x8f, 0x8f, 0xf4, 0xf4, 0xf4, 0xf4, 0x0a, 0x0a, 0x0a, 0x0a,
		}
	} else if intSize == 32 {
		blendBuf = []byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x35, 0x35, 0x35, 0xff, 0xff, 0xff, 0xff, 0x90, 0x90, 0x90, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8e, 0x8e, 0x8e, 0x8e, 0xff, 0xff, 0xff, 0xff, 0xe5, 0xe5, 0xe5, 0xe5, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02, 0xe5, 0xe5, 0xe5, 0xe5, 0xc4, 0xc4, 0xc4, 0xc4, 0xff, 0xff, 0xff, 0xff, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x41, 0x41, 0x41, 0xfe, 0xfe, 0xfe, 0xfe, 0x27, 0x27, 0x27, 0x27, 0xf4, 0xf4, 0xf4, 0xf4, 0x98, 0x98, 0x98, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9b, 0x9b, 0x9b, 0x9b, 0xc5, 0xc5, 0xc5, 0xc5, 0x00, 0x00, 0x00, 0x00, 0xa8, 0xa8, 0xa8, 0xa8, 0xeb, 0xeb, 0xeb, 0xeb, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x06, 0x06, 0xee, 0xee, 0xee, 0xee, 0x6f, 0x6f, 0x6f, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x53, 0x53, 0x53, 0x53, 0xff, 0xff, 0xff, 0xff, 0x48, 0x48, 0x48, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x4e, 0x4e, 0x4e, 0x4e, 0xfd, 0xfd, 0xfd, 0xfd, 0x1a, 0x1a, 0x1a, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x09, 0xf3, 0xf3, 0xf3, 0xf3, 0xa0, 0xa0, 0xa0, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0xa7, 0xa7, 0xa7, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf0, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00,
			0x0b, 0x0b, 0x0b, 0x0b, 0xf5, 0xf5, 0xf5, 0xf5, 0x75, 0x75, 0x75, 0x75, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x61, 0x61, 0x61, 0x61, 0xff, 0xff, 0xff, 0xff, 0x50, 0x50, 0x50, 0x50, 0x00, 0x00, 0x00, 0x00,
			0x5a, 0x5a, 0x5a, 0x5a, 0xf6, 0xf6, 0xf6, 0xf6, 0x0e, 0x0e, 0x0e, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0xe9, 0xe9, 0xe9, 0xe9, 0xa8, 0xa8, 0xa8, 0xa8, 0x00, 0x00, 0x00, 0x00,
			0xb3, 0xb3, 0xb3, 0xb3, 0xa7, 0xa7, 0xa7, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x8f, 0x8f, 0x8f, 0xf5, 0xf5, 0xf5, 0xf5, 0x0b, 0x0b, 0x0b, 0x0b,
		}
	}

	wantBlend := &Bitmap{
		userCreated: true, //we're blending into a newed bitmap, irrelevant otherwise
		Rows:        11,
		Width:       10,
		Pitch:       40,
		Buffer:      blendBuf,
		NumGrays:    256,
		PixelMode:   PixelModeBGRA,
	}

	if _, err := face.GlyphSlot().Bitmap.Blend(l, Vector26_6{}, b, color.RGBA{255, 255, 255, 255}); err != nil {
		t.Errorf("Bitmap.Blend() error = %v", err)
	}
	if diff := diff(b, wantBlend); diff != nil {
		t.Fatalf("Bitmap.Blend() = %v", diff)
	}

	// blend onto itself
	if _, err := b.Blend(l, Vector26_6{}, b, color.RGBA{255, 255, 255, 255}); err != nil {
		t.Errorf("Bitmap.Blend() error = %v", err)
	}
	if diff := diff(b, wantBlend); diff != nil {
		t.Fatalf("Bitmap.Blend() = %v", diff)
	}

	var doubleBlendBuf []byte
	if intSize == 64 {
		doubleBlendBuf = []byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x5e, 0x5e, 0x5e, 0xff, 0xff, 0xff, 0xff, 0xcd, 0xcd, 0xcd, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xfc, 0xfc, 0xfc, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0xfc, 0xfc, 0xfc, 0xfc, 0xf1, 0xf1, 0xf1, 0xf1, 0xff, 0xff, 0xff, 0xff, 0x6e, 0x6e, 0x6e, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x71, 0x71, 0x71, 0xfe, 0xfe, 0xfe, 0xfe, 0x48, 0x48, 0x48, 0x48, 0xfe, 0xfe, 0xfe, 0xfe, 0xd4, 0xd4, 0xd4, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd7, 0xd7, 0xd7, 0xd7, 0xf1, 0xf1, 0xf1, 0xf1, 0x00, 0x00, 0x00, 0x00, 0xe1, 0xe1, 0xe1, 0xe1, 0xfd, 0xfd, 0xfd, 0xfd, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x09, 0xfd, 0xfd, 0xfd, 0xfd, 0xad, 0xad, 0xad, 0xad, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x8a, 0x8a, 0x8a, 0xff, 0xff, 0xff, 0xff, 0x7a, 0x7a, 0x7a, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x84, 0x84, 0x84, 0x84, 0xfe, 0xfe, 0xfe, 0xfe, 0x31, 0x31, 0x31, 0x31, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0xfe, 0xfe, 0xfe, 0xfe, 0xda, 0xda, 0xda, 0xda, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0xe0, 0xe0, 0xe0, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0x0d, 0x0d, 0x0d, 0x0d, 0x00, 0x00, 0x00, 0x00,
			0x15, 0x15, 0x15, 0x15, 0xfe, 0xfe, 0xfe, 0xfe, 0xb4, 0xb4, 0xb4, 0xb4, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x9d, 0x9d, 0x9d, 0x9d, 0xff, 0xff, 0xff, 0xff, 0x85, 0x85, 0x85, 0x85, 0x00, 0x00, 0x00, 0x00,
			0x94, 0x94, 0x94, 0x94, 0xfe, 0xfe, 0xfe, 0xfe, 0x1b, 0x1b, 0x1b, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0xfd, 0xfd, 0xfd, 0xfd, 0xe0, 0xe0, 0xe0, 0xe0, 0x00, 0x00, 0x00, 0x00,
			0xe8, 0xe8, 0xe8, 0xe8, 0xe0, 0xe0, 0xe0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcd, 0xcd, 0xcd, 0xcd, 0xfe, 0xfe, 0xfe, 0xfe, 0x13, 0x13, 0x13, 0x13,
		}
	} else if intSize == 32 {
		doubleBlendBuf = []byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x5e, 0x5e, 0x5e, 0xff, 0xff, 0xff, 0xff, 0xce, 0xce, 0xce, 0xce, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xfc, 0xfc, 0xfc, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0xfc, 0xfc, 0xfc, 0xfc, 0xf1, 0xf1, 0xf1, 0xf1, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x6f, 0x6f, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x71, 0x71, 0x71, 0xfe, 0xfe, 0xfe, 0xfe, 0x48, 0x48, 0x48, 0x48, 0xfe, 0xfe, 0xfe, 0xfe, 0xd5, 0xd5, 0xd5, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd7, 0xd7, 0xd7, 0xd7, 0xf1, 0xf1, 0xf1, 0xf1, 0x00, 0x00, 0x00, 0x00, 0xe1, 0xe1, 0xe1, 0xe1, 0xfd, 0xfd, 0xfd, 0xfd, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x0b, 0x0b, 0x0b, 0x0b, 0xfd, 0xfd, 0xfd, 0xfd, 0xad, 0xad, 0xad, 0xad, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x8a, 0x8a, 0x8a, 0xff, 0xff, 0xff, 0xff, 0x7b, 0x7b, 0x7b, 0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x84, 0x84, 0x84, 0x84, 0xfe, 0xfe, 0xfe, 0xfe, 0x31, 0x31, 0x31, 0x31, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0xfe, 0xfe, 0xfe, 0xfe, 0xdb, 0xdb, 0xdb, 0xdb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0xe0, 0xe0, 0xe0, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0x0d, 0x0d, 0x0d, 0x0d, 0x00, 0x00, 0x00, 0x00,
			0x15, 0x15, 0x15, 0x15, 0xfe, 0xfe, 0xfe, 0xfe, 0xb4, 0xb4, 0xb4, 0xb4, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x9d, 0x9d, 0x9d, 0x9d, 0xff, 0xff, 0xff, 0xff, 0x86, 0x86, 0x86, 0x86, 0x00, 0x00, 0x00, 0x00,
			0x94, 0x94, 0x94, 0x94, 0xfe, 0xfe, 0xfe, 0xfe, 0x1b, 0x1b, 0x1b, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0xfd, 0xfd, 0xfd, 0xfd, 0xe1, 0xe1, 0xe1, 0xe1, 0x00, 0x00, 0x00, 0x00,
			0xe8, 0xe8, 0xe8, 0xe8, 0xe0, 0xe0, 0xe0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcd, 0xcd, 0xcd, 0xcd, 0xfe, 0xfe, 0xfe, 0xfe, 0x15, 0x15, 0x15, 0x15,
		}
	}

	wantDoubleBlend := &Bitmap{
		userCreated: true, //we're blending into a newed bitmap, irrelevant otherwise
		Rows:        11,
		Width:       10,
		Pitch:       40,
		Buffer:      doubleBlendBuf,
		NumGrays:    256,
		PixelMode:   PixelModeBGRA,
	}

	// blend it again
	if _, err := face.GlyphSlot().Bitmap.Blend(l, Vector26_6{}, b, color.RGBA{255, 255, 255, 255}); err != nil {
		t.Errorf("Bitmap.Blend() error = %v", err)
	}
	if diff := diff(b, wantDoubleBlend); diff != nil {
		t.Fatalf("Bitmap.Blend() = %v", diff)
	}
}

func TestGlyphSlot_OwnBitmap(t *testing.T) {
	var slot *GlyphSlot

	if err := slot.OwnBitmap(); err != nil {
		t.Errorf("GlyphSlot.OwnBitmap() error = %v", err)
	}

	face, err := goRegular()
	if err != nil {
		t.Fatalf("unable to load face: %v", err)
	}
	defer face.Free()

	if err := face.GlyphSlot().OwnBitmap(); err != nil {
		t.Errorf("GlyphSlot.OwnBitmap() error = %v", err)
	}
}
